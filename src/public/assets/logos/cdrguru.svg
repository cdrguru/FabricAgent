<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" role="img" aria-labelledby="svg-title"
     style="
       /* Per-instance theme variables (override per embed) */
       --clr-path:#4A5568;        /* Gray-600 */
       --clr-progress:#63B3ED;    /* Blue-300 */
       --clr-token-stroke:#1A202C;/* Gray-900 */
       --clr-label-text:#E2E8F0;  /* Gray-200 */
       --clr-idle:#A0AEC0;        /* Gray-400 */
       --clr-ringing:#4299E1;     /* Blue-400 */
       --clr-answered:#48BB78;    /* Green-400 */
       --clr-abandoned:#F56565;   /* Red-400 */
     ">
  <title id="svg-title">Live Call Flow Visualizer</title>
  <desc>An animation showing a call moving along a path, representing its journey through a queue. The call's state, progress, and speed are updated dynamically from a data source. The token is focusable.</desc>

  <style>
    /* Base Path Styles */
    .call-path {
      fill: none;
      stroke: var(--clr-path, #4A5568);
      stroke-width: 2;
      vector-effect: non-scaling-stroke;
      shape-rendering: geometricPrecision;
    }
    .call-path.progress {
      stroke: var(--clr-progress, #63B3ED);
      opacity: .6;
      stroke-dasharray: 0 100; /* 0% progress initially (uses pathLength=100) */
      transition: stroke-dasharray 0.1s linear; /* smooth progress updates */
    }

    /* Token + Label */
    .call-token {
      transition: fill 0.3s ease-in-out;
      fill: var(--clr-idle, #A0AEC0);
      stroke: var(--clr-token-stroke, #1A202C);
      stroke-width: 2;
      visibility: hidden; /* hidden until a call event occurs */
      cursor: pointer;
    }
    .focus-ring {
      pointer-events: none;
      opacity: 0; /* shown on focus */
    }
    .call-label {
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 14px;
      fill: var(--clr-label-text, #E2E8F0);
      text-anchor: middle;
      dominant-baseline: middle;
      visibility: hidden; /* shown with token visibility */
    }

    /* State Classes (driven by JS) */
    .is-visible { visibility: visible; }
    .call-token.is-ringing  { fill: var(--clr-ringing,  #4299E1); }
    .call-token.is-answered { fill: var(--clr-answered, #48BB78); }
    .call-token.is-abandoned{ fill: var(--clr-abandoned,#F56565); }

    /* Focus handling in SVG (outline is unreliable) */
    #cdrg1-token:focus .focus-ring { opacity: 1; }

    /* Accessibility Preferences */
    @media (prefers-reduced-motion: reduce) {
      .call-path.progress { transition: none; }
    }
    @media (prefers-contrast: more) {
      .call-path { stroke-width: 3; }
      .call-label {
        fill: #000;
        stroke: #fff;
        stroke-width: 1px;
        paint-order: stroke;
      }
    }
    @media (forced-colors: active) {
      .call-path, .call-path.progress, .focus-ring { stroke: CanvasText; }
      .call-token { stroke: CanvasText; fill: ButtonFace; }
      .call-label { fill: CanvasText; stroke: Canvas; }
    }
  </style>

  <!-- Normalized motion path with pathLength=100 for easy progress math -->
  <defs>
    <path id="cdrg1-call-flow-path"
          class="call-path"
          d="M20,100 C150,20 450,180 580,100"
          pathLength="100"/>
  </defs>

  <!-- Base path + progress overlay -->
  <use href="#cdrg1-call-flow-path" />
  <use href="#cdrg1-call-flow-path" class="call-path progress" id="cdrg1-progress"/>

  <!-- Token group (focusable) -->
  <g id="cdrg1-token" class="call-token" tabindex="0" focusable="true" aria-labelledby="svg-title">
    <!-- Focus ring for keyboard users -->
    <circle class="focus-ring" r="12" fill="none" stroke="var(--clr-ringing, #4299E1)" stroke-width="2"/>
    <!-- Actual token glyph -->
    <circle r="8"/>
    <!-- Dynamic label -->
    <text id="cdrg1-mos-label" class="call-label" y="-15">MOS: -</text>
  </g>

  <script>
    (function(){
      // Element refs
      const token       = document.getElementById('cdrg1-token');
      const label       = document.getElementById('cdrg1-mos-label');
      const path        = document.getElementById('cdrg1-call-flow-path');
      const progressEl  = document.getElementById('cdrg1-progress');

      // Create or attach a polite live region for announcements
      let sr = document.getElementById('sr-updates');
      if (!sr) {
        sr = document.createElement('span');
        sr.id = 'sr-updates';
        sr.setAttribute('aria-live','polite');
        Object.assign(sr.style, {
          position:'absolute', width:'1px', height:'1px', overflow:'hidden',
          clip:'rect(1px,1px,1px,1px)', clipPath:'inset(50%)', whiteSpace:'nowrap'
        });
        (document.body || document.documentElement).appendChild(sr);
      }

      // Helpers
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const len = path.getTotalLength(); // REAL length for getPointAtLength

      function setProgress(p){ // p in [0..1]
        if(!progressEl) return;
        const pct = Math.max(0, Math.min(1, p)) * 100; // uses pathLength=100
        progressEl.setAttribute('stroke-dasharray', `${pct} ${100 - pct}`);
      }

      function jumpToEnd(){
        const end = path.getPointAtLength(len);
        token.setAttribute('transform', `translate(${end.x},${end.y})`);
        setProgress(1);
      }

      function animateViaJS(totalDurationMs){
        const start = performance.now();
        function step(now){
          const p = Math.min(1, (now - start) / totalDurationMs);
          const pt = path.getPointAtLength(p * len);
          token.setAttribute('transform', `translate(${pt.x},${pt.y})`);
          setProgress(p);
          if(p < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }

      // Main event handler (exposed)
      function onEvent(e){
        if(!token) return;

        // Visibility + state
        token.classList.add('is-visible');
        label.classList.add('is-visible');
        token.classList.remove('is-ringing','is-answered','is-abandoned');

        const ev = (e && e.event) || 'Offered';
        if (ev === 'Offered')   token.classList.add('is-ringing');
        if (ev === 'Answered')  token.classList.add('is-answered');
        if (ev === 'Abandoned') token.classList.add('is-abandoned');

        // Label + SR announce
        const mos = (e && typeof e.mos === 'number') ? e.mos : '-';
        label.textContent = `MOS: ${mos}`;
        sr.textContent = `Call ${ev}. MOS ${mos}.`;

        // Motion
        const durationMs
