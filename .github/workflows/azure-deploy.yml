name: Deploy FabricAgent to Azure
run-name: "Deploy: ${{ github.sha || github.run_id }} â€” ${{ github.event.head_commit.message }}"

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'public/**'
      - 'schemas/**'
      - 'prompts/**'
      - '.github/workflows/azure-deploy.yml'
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20.19.0'

      # Build frontend
      - name: Build frontend
        working-directory: ./src
        env:
          # Prefer HELP_CENTER_URL if set; code reads this first.
          VITE_HELP_CENTER_URL: ${{ vars.VITE_HELP_CENTER_URL }}
          VITE_HELP_URL: ${{ vars.VITE_HELP_URL }}
        run: |
          npm install
          # Workaround for rollup native binary resolution on Linux runners
          npm install @rollup/rollup-linux-x64-gnu --no-save || true
          npm run build

      # Assemble release
      - name: Assemble release (self-contained)
        run: |
          rm -f release.zip
          mkdir -p release
          cp -r src/dist/* release/

          # Always write a robust no-deps server (serves release/ and exposes /api/rewrite)
          cat > release/server.mjs <<'SERVER'
          #!/usr/bin/env node
          import http from 'node:http';
          import { parse } from 'node:url';
          import { promises as fs } from 'node:fs';
          import path from 'node:path';

          const PORT = process.env.PORT || 8080;
          const DIST = process.cwd(); // serve files we copied into release/

          function contentType(p){
            const ext = path.extname(p).toLowerCase();
            return ({
              '.html':'text/html; charset=utf-8', '.js':'application/javascript; charset=utf-8', '.css':'text/css; charset=utf-8', '.svg':'image/svg+xml', '.json':'application/json; charset=utf-8', '.ico':'image/x-icon'
            }[ext] || 'application/octet-stream');
          }

          function send(res, code, body, headers={}){
            const data = typeof body === 'string' || Buffer.isBuffer(body) ? body : JSON.stringify(body);
            res.writeHead(code, { 'Content-Type': typeof body === 'string' ? 'text/plain; charset=utf-8' : 'application/json; charset=utf-8', 'Access-Control-Allow-Origin':'*', ...headers });
            res.end(data);
          }

          function logEnvPresence(){
            const keys = ['AZURE_OPENAI_ENDPOINT','AZURE_OPENAI_API_KEY','AZURE_OPENAI_DEPLOYMENT','AZURE_OPENAI_API_VERSION'];
            console.log('[server] env presence:', Object.fromEntries(keys.map(k => [k, Boolean(process.env[k])])));
          }

          async function handleRewrite(req, res){
            try{
              const chunks=[]; for await (const ch of req) chunks.push(ch);
              const raw = Buffer.concat(chunks).toString('utf-8');
              const body = raw ? JSON.parse(raw) : {};
              const text = body.text || '';
              const instruction = body.instruction || 'Rewrite clearly while preserving technical accuracy.';
              const endpoint = process.env.AZURE_OPENAI_ENDPOINT;
              const apiKey = process.env.AZURE_OPENAI_API_KEY;
              const apiVersion = process.env.AZURE_OPENAI_API_VERSION || '2024-02-15-preview';
              const deployment = body.deployment || process.env.AZURE_OPENAI_DEPLOYMENT || 'gpt-5-mini';
              if (!endpoint || !apiKey) return send(res, 500, { error: 'Missing Azure OpenAI configuration' });
              const url = `${endpoint.replace(/\/$/, '')}/openai/deployments/${deployment}/chat/completions?api-version=${encodeURIComponent(apiVersion)}`;
              const base = { messages: [ { role:'system', content:'You are a helpful rewriting assistant. Improve clarity and tone while preserving meaning.' }, { role:'user', content:`Instruction: ${instruction}\n\nText to rewrite:\n${text}` } ], temperature: 1, n: 1 };
              async function call(p){ return fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json','api-key':apiKey }, body: JSON.stringify(p) }); }
              let r = await call({ ...base, max_completion_tokens: 800 });
              if (!r.ok){ const t = await r.text().catch(()=> ''); if (/max_completion_tokens/i.test(t) || /Unrecognized request argument/i.test(t)) { r = await call({ ...base, max_tokens: 800 }); } else { return send(res, r.status, { error:'Azure OpenAI error', details:t }); } }
              const data = await r.json();
              const output = data?.choices?.[0]?.message?.content || '';
              return send(res, 200, { output }, { 'Access-Control-Allow-Origin':'*' });
            } catch(e){ return send(res, 500, { error: String(e?.message || e) }); }
          }

          async function serveStatic(req, res, pathname){
            try{
              let filePath = path.join(DIST, decodeURIComponent((pathname||'/').replace(/^\/+/, '')));
              if (!filePath.startsWith(DIST)) return send(res, 403, 'Forbidden');
              let stat; try{ stat = await fs.stat(filePath); } catch { stat = null; }
              if (!stat || stat.isDirectory()) filePath = path.join(DIST, 'index.html');
              const buf = await fs.readFile(filePath);
              res.writeHead(200, { 'Content-Type': contentType(filePath) });
              res.end(buf);
            } catch { return send(res, 404, 'Not found'); }
          }

          const server = http.createServer(async (req, res) => {
            const { pathname } = parse(req.url || '/');
            if (req.method === 'GET' && pathname === '/health') return send(res, 200, JSON.stringify({ ok:true, ts:new Date().toISOString() }), { 'Content-Type':'application/json' });
            if (pathname?.startsWith('/api/rewrite') && req.method === 'POST') return handleRewrite(req, res);
            return serveStatic(req, res, pathname);
          });

          server.listen(PORT, () => { logEnvPresence(); console.log(`[server] listening on :${PORT}, root ${DIST}`); });
          SERVER

          cat > release/package.json <<'JSON'
          {
            "name": "fabricagent-spa",
            "private": true,
            "version": "0.1.0",
            "type": "module",
            "scripts": { "start": "node server.mjs" },
            "engines": { "node": ">=20" }
          }
          JSON

          printf '{"version":"%s","runId":"%s","builtAt":"%s"}\n' \
            "${GITHUB_SHA}" "${GITHUB_RUN_ID}" "$(date -u +%FT%TZ)" > release/version.json

          (cd release && zip -r ../release.zip .)

      # Azure login via OIDC
      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          audience: api://AzureADTokenExchange

      - name: Debug context
        run: |
          az account show
          az webapp show -g "${{ vars.AZURE_RESOURCE_GROUP }}" -n "${{ vars.AZURE_WEBAPP_NAME }}" --query "{name:name, hostName:defaultHostName, kind:kind, linuxFx:siteConfig.linuxFxVersion}" -o json

      # Optional: ensure Node version/app settings on the Web App
      - name: Configure app settings (opt-in)
        if: ${{ vars.CONFIGURE_APP_SETTINGS == 'true' }}
        run: |
          az webapp config appsettings set \
            -g "${{ vars.AZURE_RESOURCE_GROUP }}" \
            -n "${{ vars.AZURE_WEBAPP_NAME }}" \
            --settings WEBSITE_NODE_DEFAULT_VERSION=~20 WEBSITE_RUN_FROM_PACKAGE=1

      - name: Set startup command (npm start)
        run: |
          az webapp config set \
            -g "${{ vars.AZURE_RESOURCE_GROUP }}" \
            -n "${{ vars.AZURE_WEBAPP_NAME }}" \
            --startup-file "npm start"
          # Give SCM container a moment to settle before deploy to avoid restart race
          sleep 10

      - name: Enable container logs (opt-in)
        if: ${{ vars.ENABLE_DOCKER_LOGS == 'true' }}
        run: |
          az webapp log config \
            -g "${{ vars.AZURE_RESOURCE_GROUP }}" \
            -n "${{ vars.AZURE_WEBAPP_NAME }}" \
            --docker-container-logging filesystem

      # Deploy the prebuilt folder
      - name: Deploy to App Service (Linux)
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ vars.AZURE_WEBAPP_NAME }}
          resource-group-name: ${{ vars.AZURE_RESOURCE_GROUP }}
          # package: src/dist   # (verify script hint)
          package: release.zip

      - name: Smoke test
        run: |
          HN=$(az webapp show -g "${{ vars.AZURE_RESOURCE_GROUP }}" -n "${{ vars.AZURE_WEBAPP_NAME }}" --query defaultHostName -o tsv)
          echo "Host: https://${HN}"
          echo "Version:"
          curl -fsS "https://${HN}/version.json" | jq .
          echo "Root headers:"
          curl -fsSI "https://${HN}/" | sed -n '1,12p'
